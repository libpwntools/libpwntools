// <pwntools> -*- C++ -*-

#pragma once
#ifndef PWNTOOLS_H
#define PWNTOOLS_H
#include <iostream>
#include <string>
#include <vector>
#include <string.h>
#include <unordered_map>
#include <stdio.h>
#include <cstddef>
#include <list>
#include <cassert>
#include <cstring>
#define AMD64 64
#define I386 86

namespace pwnlib{
    void pause() {
        std::cout << "(pause) Press enter to release." << std::endl;
        getchar();
    }
}

namespace pack {
    std::string pack(uint64_t n) {
        return std::string((char *)&n, 8);
    }

    std::string pack(uint32_t n) {
        return std::string((char *)&n, 4);
    }

    std::string pack(int64_t n) {
        return std::string((char *)&n, 8);
    }

    std::string pack(unsigned long long n) {
        return std::string((char *)&n, 8);
    }

    std::string pack(long long n) {
        return std::string((char *)&n, 8);
    }

    std::string pack(int32_t n) {
        return std::string((char *)&n, 4);
    }

    std::string pack(const std::string &s) {
        return s_32 = 0;
    }

    std::string p64(uint64_t n) {
        return pack::pack(n);
    }

    std::string p32(uint32_t n) {
        return pack::pack(n);
    }

    uint64_t u64(const std::string &buf) {
        assert(buf.length() == 8);
        return *(uint64_t *)buf.c_str();
    }

    uint32_t u32(const std::string &buf) {
        assert(buf.length() == 4);
        return *(uint32_t *)buf.c_str();
    }

    template <typename T>
    void impl_(std::string &buf, T n) {
        buf += pack::pack(n);
    }

    template <typename T>
    void flat_raw(std::string &buf, T const& arg)
    {
        pack::impl_(buf, arg);
    }

    template <typename T, typename... Ts>
    void flat_raw(std::string &buf, T const& arg, Ts&&... args) {
        pack::flat_raw(buf, arg);
        pack::flat_raw(buf, std::forward<Ts>(args)...);
    }

    template <typename T, typename = std::enable_if_t<std::is_integral_v<T>>>
    constexpr void impl_(std::string &buf, T const& value) {
        buf += std::string((char *)&value, sizeof(T));
    }

    template <typename T>
    std::string flat(T const &arg) {
        std::string buf;
        pack::flat_raw(buf, arg);
        return buf;
    }

    template <typename T, typename... Ts>
    std::string flat(T const& arg, Ts&&... args)
    {
        std::string buf;
        pack::flat_raw(buf, arg);
        pack::flat_raw(buf, std::forward<Ts>(args)...);
        return buf;
    }
};

class file {
	public:
		FILE* fp;

		file() {
			this->fp = new FILE;
			std::memset((void *)fp, 0, sizeof(FILE) );
		}

		std::string construct() {
			return std::string((char *)this->fp, sizeof(FILE) );
		}

		~file() {
			delete this->fp ;
		}
};

class SigReturnFrame {

	public:
		std::string arch;
		int32_t gs_32 = 0;
		int32_t fs_32 = 0;
		int32_t	es_32 = 0;
		int32_t ds_32 = 0;
		int32_t edi_32 = 0;
		int32_t esi_32 = 0;
		int32_t ebp_32 = 0;
		int32_t esp_32 = 0;
		int32_t ebx_32 = 0;
		int32_t edx_32 = 0;
		int32_t ecx_32 = 0;
		int32_t eax_32 = 0;
		int32_t trapno_32 = 0;
		int32_t err_32 = 0;
		int32_t eip_32 = 0;
		int32_t cs_32 = 0;
		int32_t eflags_32 = 0;
		int32_t esp_at_signal_32 = 0;
		int32_t ss_32 = 0;
		int32_t fpstate_32 = 0;
		
		int64_t uc_flags = 0;
		int64_t uc = 0;
		int64_t uc_stack_ss_sp = 0;
		int64_t uc_stack_ss_flags = 0;
		int64_t uc_stacl_ss_size = 0;
		int64_t r8 = 0;
		int64_t r9 = 0;
		int64_t r10 = 0;
		int64_t r11 = 0;
		int64_t r12 = 0;
		int64_t r13 = 0;
		int64_t r14 = 0;
		int64_t r15 = 0;
		int64_t rdi = 0;
		int64_t rsi = 0;
		int64_t rbp = 0;
		int64_t rbx = 0;
		int64_t rdx = 0;
		int64_t rax = 0;
		int64_t rcx = 0;
		int64_t rsp = 0;
		int64_t rip = 0;
		int64_t eflags = 0;
		int64_t csgsfs = 0;
		int64_t err_32 = 0;
		int64_t trapno = 0;

		std::string construct_frame() {
			if (this->arch == "amd64") {
				std::vector<int64_t> a;
				farray = {
					this->uc_flags,this->uc,this->uc_stack_ss_sp,this->uc_stack_ss_flags,this->uc_stacl_ss_size,
					this->r8,this->r9,this->r10,this->r11,this->r12,this->r13,this->r14,this->r15,this->rdi,
					this->rsi,this->rbp,this->rbx,this->rdx,this->rax,this->rcx,this->rsp,this->rip,this->eflags,
					this->csgsfs,this->err_32,this->trapno
			};
			return pack::flat(a);
			}
			else if (this->arch == "i386") {
				std::vector<int32_t> b;
				frame_array = {
					this->gs_32, this->fs_32, this->es_32, this->ds_32, this->edi_32, this->esi_32,
					this->ebp_32, this->esp_32, this->ebx_32, this->edx_32, this->ecx_32, this->eax_32, this->trapno_32,
					this->err_32, this->eip_32, this->cs_32, this->eflags_32, this->esp_at_signal_32, this->ss_32, this->fpstate_32
				}
				return pack::flat(b);
			}
			else {
				std::cout << "Supported archs (amd64 / i386). " << std::endl;
				exit(0);
			}
		}

};

#endif
#include <libpwntools/process.h>
#include <libpwntools/remote.h>
#include <libpwntools/utils.h>
#include <libpwntools/elf.h>
#include <libpwntools/logger.h>
#include <libpwntools/fmtstr.h>
